### java虚拟机家族

- sun Classic/Exact VM：Classic VM是第一款商用的JVM，采用纯解释器的方式执行代码，编译代码的话需要外挂编译器，存在时间较长，JDK1.1和1.2作为唯一的虚拟机，1.3作为备选，1.4退出了历史舞台。Exact VM时间很短， 已经具备热点探测、两级即时编译、编译器与解释器混合工作模式。
- HotSpot VM：当前默认的虚拟机，使用最广泛的虚拟机。HotSpot是指热点代码探测技术，通过执行计数器找出最具有编译价值的代码。
- Mobile/Embedded VM：面向移动设备和嵌入式设备
- BEA JRockit/IBM J9 VM：JRockit是BEA公司的JVM，采用全部即时编译后执行的方式，不关注程序启动速度，只关心程序运行速度；J9是IBM公司的JVM产品，其职责分离和模块化做的比HotSpot更优秀
- 等等，一些其他的jvm

### [虚拟机参数](https://github.com/wangjunjie0817/note/blob/master/jvm/jvm%E5%8F%82%E6%95%B0%E4%B8%8E%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE.md)

### java内存区域

#### 运行时数据区

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200901141750209.png)

1. 程序计数器：是一块比较小的空间，当前线程执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作就是通过变更这个计数器的值来选取下一步执行的字节码，分支/跳转/异常处理/线程恢复等基础的功能都是依赖这个计数器来完成。在这里不会发生OutOfMemory Error

2. 虚拟机栈：是线程私有的，和线程的生命周期相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法在执行的时候会创建一个栈桢加入到栈中，一个方法的执行伴随栈桢在虚拟机栈入栈和出栈。栈桢中存储==局部变量表、操作数栈、动态连接、方法出口等信息==

   局部变量表中存放编译期可知的各种java虚拟机基本数据类型、引用类型和returnAddress类型。由于是在编译期可知，所以在进入一个方法中时，局部变量表的大小不会发生变化。

   在这里会发生OutOfMemory Error（申请内存失败）和StackOverflow Error（超出栈深度限制）

3. 本地方法栈：和虚拟机栈类似，只不过这里存储的是native方法的栈桢，在这里会发生OutOfMemory Error（申请内存失败）和StackOverflow Error（超出栈深度限制）

4. java堆：为线程共享的一大块内存，在虚拟机启动时创建，目的就是==存放对象的实例==。几乎所有的对象实例以及数组都在堆上分配内存。堆是GC收集器管理的内存区域，在一些垃圾收集器中根据分代收集理论设计的，随意堆上会经常出现新生代、老年代、永久代、Eden空间、From Survivor空间、To Survivor空间等概念，这些概念只是一部分垃圾回收器的共同风格而已，不是堆空间结构的进一步划分，这点很重要。

   从内存分配的角度来看，堆可以划分为多个线程私有的分配缓冲区（Thread Local Allocation Buffer 也就是TLAB），以提升内存分配的效率。

5. 方法区：与堆一样，是线程间共享的区域，用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器 编译后的代码缓存等。在早期JDK版本中的HotSpot虚拟机中，采用一个名为永久代来实现方法区，这样HotSpot就可以像管理堆的方式管理永久代也就是方法区。在其他的虚拟机中是不存在永久代的概念的。由于永久代这种本身设计的局限性，在JDK7中将字符串常量池和静态变量移出永久代，在JDK8完全废弃了永久代的概念，采用和J9一样的元空间（Meta-space）来代替。

   方法区的垃圾收集是很少的，但也并不是当数据进入了方法区就永久存在了。在元空间的回收主要是针对常量池的回收和对类型的卸载。

6. 运行时常量池：运行时常量池是方法区的一部分。用于存放在编译器中产生的各种字面量与符号引用，这部分内容在类加载后存放在方法区中的运行时常量池。

#### 直接内存

直接内存不是运行时数据区的一部分，在JDK1.4中加入了NIO，引入了一种Channel和缓冲区Buffer的I/O方式，他可以使用native方法直接分配堆外内存，通过存储在java堆中的一个DirectByteBuffer对象作为这块内存的引用进行操作。这样一来提高了性能，避免了在java堆和Native堆中来回复制数据。

那么如何提升了性能呢？我们知道假设我们读取文件数据，首先需要将文件数据加载到系统内存中，系统内存通过jni将内存中的数据拷贝到堆中。那如果我们使用了直接内存，可以少一次从内存中拷贝到堆的过程。

在NIO中使用DirectByteBuffer存储数据，当调用flush方法发送数据，数据可以直接发送。而如果采用HeapByteBuffer存储数据，flush发送数据时，需要先将数据拷贝到直接内存中，然后再调用下一步操作。

直接内存的内存管理：在new一个DirectByteBuffer时，DirectByteBuffer的构造方法调用Cleaner.create将自己包装成为一个PhantomReference对象，当这个对象在堆中被GC，此时这个对象会被加入到对应的Queue中，此时会触发cleaner中的clean方法，clean方法回调DirectByteBuffer的Deallocator的run方法，实现DirectByteBuffer对象内存释放。

除此之外，直接内存和零拷贝也不是一个概念，重点看下图。

#### 零拷贝

这篇文章很屌

https://www.jianshu.com/p/2fd2f03b4cc3

### java堆对象创建、布局、访问

#### 对象的创建

当java虚拟机遇到了一个new指令时，首先去检查这个new指令的参数在运行时常量池中定位到一个类的符号引用，并且检查这个符号引用是否被加载、解析、初始化过，如果没有，就执行类的加载过程。

加载完成后，对象所需的内存大小就可以确定了，为对象分配内存等同于一块确定大小的内存从堆中划分出来。内存分配的方式根据空闲空间是否规整，分为==指针碰撞==和==空闲列表==两种方式，堆空闲内存是否规整取决于采用的垃圾收集算法。

在划分内存时，由于并发情况下，划分内存不是线程安全的，所以需要采取同步策略，解决同步问题两种方案：==CAS==和==TLAB==， TLAB是预先为每个线程分配一小块内存，在分配内存时首先在TLAB进行分配，当TLAB中没有内存，采用CAS方式分配。

内存分配完成之后，将除对象头外的分配的内存空间全部初始化为0

接下来设置对象头信息

最后的一个步骤就是执行初始化方法，也就是执行Class文件中的\<init>方法，这样一个兑现才算完整的创建出来。

#### 对象的内存布局

在HotSpot虚拟机中，对象在堆内存中的存储布局可以分为三大部分：对象头、实例数据、对齐填充。

对象头存储对象的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对于数据数据，对象头需要存储数组的长度。

实例数据：即我们定义的实力对象的字段的值

对齐填充：对象的大小必须是8字节的整数倍，如果对象的数据部分没有补齐的话，就需要对齐填充来补齐。

#### 对象的访问定位

java程序会通过栈上的Reference数据来操作堆上的对象，主流的方式有==使用句柄==和==直接指针==两种方法

两种方法各有优点，使用句柄的话，当对象的地址变更，只需要变更句柄中的实例对象指针；使用直接指针优点就是访问速度快。

### 垃圾收集器与内存分配策略

这部分的内容主要关心的是堆内存和方法区的内存管理

#### 如何判断对象已死

##### 引用计数算法

在对象中添加一个引用计数器，在其他地方引用一次，计数器+1，引用失效，计数器-1，当引用计数为0时，对象可回收。优点是原理简单，判定准确率高；缺点是有很多额外的情况需要考虑，例如由于循环引用的问题导致两个对象都不可以回收。

##### 可达性分析算法

通过一系列的GC Roots的根对象为起始节点，如果对象和GC Roots不可达，则证明当前对象可回收

可作为GC Roots的对象有：

- 虚拟机栈中引用到的对象，例如方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中静态变量引用的对象
- 方法区中常量引用的对象
- 在本地方法栈中jni引用的对象
- 虚拟机内部的引用，例如基本类型对应的Class对象，一些常驻的异常对象，系统类加载器
- 所有被同步锁持有的对象
- 反映jvm内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

##### 对象是生是死

通过上述的方法判断对象不可达，也并不是非死不可。想要宣告一个对象彻底死亡还需要两次的标记：如果对象在可达性分析时发现对象没有和GC Roots连接，那么将对它做第一次的标记。随后会对对象做一次筛选，筛选的条件是该对象是否有必要执行finalize方法，如果没有重写过finalize方法或者finalize 方法已经执行过，则认为没有必要执行。

如果有必要执行，会将这个对象加入到一个名为F-Queue的队列中，并且有一个虚拟机自动建立的，低调度优先级的Finalizer线程去执行他们的finalize方法。finalize方法是对象自救的最后一次机会，如果在finalize方法中，对象与不会回收的对象建立关联，那么将自救成功，否则这个对象基本上就会被回收了。

注意，一个对象的finalize方法只会被执行一次，也就是说，只能通过finalize方法自救一次。

finalize方法设计的初衷是为了让C、C++用户更好接受java，现在官方不推荐使用这种用法。而是推荐在这个方法中实现资源的清理工作，但是我们可以使用try finally语法实现资源的释放。总之finalize方法是运行代价高昂、不确定性大、无法保证各个对象的执行顺序。

所以这个方法可以放弃了。

#### 引用类型

- 强引用
- 弱引用
- 软引用
- 虚引用：一个对象是否有虚引用的存在，不会对其生命周期造成影响，也无法通过虚引用获得引用的对象。只是为了对象在被收集器回收时得到一个系统通知。

#### 回收方法区

首先，java虚拟机规范提到过不要求虚拟机在方法区实现垃圾收集。

方法区的回收主要回收两部分内容：废弃的常量和不再使用的类型。

废弃的常量 判定比较简单，只需要没有任何字段引用，并且虚拟机也没有用到这个常量，此时如果虚拟机判定这个常量有必要清理，那么这个常量会被回收

不再使用的类型则相对复杂，回收需要满足以下三个条件：

1. 所有该类的对象都已经被回收
2. 加载该类的类加载器已经被回收，这个条件很难达成
3. 该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

#### 垃圾收集算法

##### 分代收集理论

当前商业虚拟机的垃圾收集器大多数遵循了分代收集的理论，分代理论是建立在两个假说之上的：

1. 弱分代假说：绝大多数对象是朝生夕灭的、
2. 抢分代假说：熬过多次GC的对象越难被回收
3. 跨代引用假说：跨代引用相对于同代引用来讲仅占极少数

有了分代收集的理论，就可以将回收的对象根据对象年龄分配到不同的区域之中存储。在目前的java虚拟机中，设计者会将java堆分成新生代和老年代两个区域。在新生代中每次GC都会收集大量的对象，多次没有被收集的对象逐渐晋升到老年代存放。

为了解决跨代引用的问题，我们不应该为了少量的跨代引用去扫描整个老年代，也不能浪费空间记录每一个对象是否以及存在多少跨代引用。所以采用在新生代建立一个全局的数据结构--->记忆集 Remember Set，记忆集将老年代空间划分为多个小块，并且只记录存在跨代引用的小块，这样在发生Minor GC时只有存在跨代引用小块中的对象才会被加入GC Roots进行扫描。

##### GC分类

- Partial GC：指不是所有的堆都收集，部分收集，Minor GC、Major GC、Mixed GC的总称
- Minor GC/Young GC：新生代的垃圾收集
- Major GC/Old GC：老年代的垃圾收集
- Mixed GC：新生代和部分老年代的垃圾收集，只有G1收集器会这样回收
- Full GC：整个堆区域和方法区的收集

##### 标记清除算法

算法分为标记和清除两个阶段，首先标记出需要回收的对象，在标记完成之后，统一回收所有被标记的对象。

算法比较简单，缺点很明显：

- 执行效率不稳定，标记和清除两个部分都随着对象数量增长而降低。
- 内存的碎片化问题，当有大对象分配时无法找到足够的连续内存会提前触发另一次垃圾收集的动作。

##### 标记复制算法

将内存按容量划分为两个相等的部分，每次只使用其中的一块。当一块内存用完了，就将还存活着的对象复制到另外一块内存，然后再把使用过的内存一次性全部清理掉。

缺点：

- 可用的内存变成了原来的一半，浪费内存空间

针对内存浪费的情况，提出了一种更优化的半区复制分代策略，称为Appel式回收。Appel回收的具体做法是将新生代内存分为Eden区和两块较小的Survivor区，每次分配内存只使用Eden区和一块Survivor内存。发生垃圾收集时，将Eden区和Survivor区的存活对象一次性的复制到另一块Survivor区，然后直接清理掉Eden区和Survivor区的内存。当Survivor 的内存不足时（非常小概率），会使用老年代进行担保。

##### 标记整理算法

标记整理算法中，标记的过程和标记清除算法一样，不过在整理的过程中，会将存活的对象都向内存的内存空间的一端移动，然后清理掉边界以外的内存。

从效率上看，标记整理算法回收内存效率低，标记清除分配内存的效率低，所以各有利弊。

关注吞吐量的收集算法Parallel Scavenge是基于标记整理算法的，关注回收效率的算法CMS大多数情况下是基于标记清除算法的，当碎片率不能忍受时，采用标记整理算法收集一次整理内存。

#### HotSpot的算法实现细节

##### 枚举根节点（安全点、安全区域、OopMap）

枚举根节点即为GC Roots的一个枚举。GC Roots中一般为全局性引用（常量、类静态属性）和执行上下文（栈帧中的本地变量表）。而枚举出这个GC Roots我们需要考虑到这个分析过程所产生结果的准确性及枚举效率，也就是我们此时要讲的保证“一致性”快照和提高枚举效率。

> 一、如何确保“一致性”快照，保证分析结果的准确性
>
> 这个“一致性”的意思是指在整个分析期间整个执行系统看起来就好像冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断地发生变化地情况，该点不满足地话分析结果的准确性就无法得到保证。这一点也是GC进行时必须停顿所有执行线程的一个重要原因。而JVM为了解决这一个问题，选取一个特定位置作为“安全点（SafePoint）”。
>
> **① 什么是安全点？如何选取安全点？**
>
> “安全点”简单点说就是程序执行停顿下的这一个点。程序在执行时，并非在所有的地方都能停下来开始GC，只有到达这个“安全点“时才能停顿下来。安全点的选区既不能太少以至于让GC等待时间过长，也不能过于频繁以至于过分增大运行时的负荷。所以，”安全点“的选择基本上是以程序”是否具有让程序长时间执行的特征“为标准来选定的。因为每条执行指令执行的时间都非常地短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，而程序”长时间的运行“实际上就是指令序列的一个复用。例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生”安全点“。而当我们选取好”安全点“之后，我们又是怎样使所有执行线程跑到”安全点“时停顿下来呢？
>
> **② ”安全点“的两种中断方式（抢先式中断和主动式中断）**
>
> “抢先式中断”不需要线程的执行代码去主动配合，在GC发生时，首次会把所有的线程全部中断，如果发现有些线程中断点不是安全点，就恢复该线程直到安全点上停止。”主动式中断“实际上就是线程主动轮询的一个过程，当GC需要中断线程时，不直接对线程进行操作，仅仅简单的设置一个标志，这个轮询标志当然要与安全点相重合。各个线程在执行的时候都会主动去询问这个轮询标志：”我是否到了该中断的点了？“。现在大部分虚拟机都采用是”主动式中断”方式，因为它相对“抢先式中断”方式避免了一个中断——>启动——>又中断的一个过程。
>
> 设置“安全点”虽然保证了大部分线程停顿，但总有一些线程比较“懒”。例如，当GC请求中断时，该线程正在偷懒sleep（），JVM不可能等该线程睡醒之后到达安全点之后才能进行可达性分析过程，而此时如果该线程睡醒了恰巧GC又在进行可达性分析或者是回收，那该线程又该何去何从呢？所以JVM又在安全点的基础上加了一个双重保险——安全区域。
>
> **③ “安全点”的双重保证——安全区域**
>
> 安全区域是指在一段代码片中，引用关系不会发生改变，实际上就是一个安全点的拓展。当线程执行到安全区域时，首先标识自己已进入安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为“安全区域”状态的线程了，该线程只能乖乖的等待根节点枚举或者整个GC过程完成之后才能继续执行。
>
> 二、在海量的对象中如何快速枚举根节点？
>
> 我们都知道在枚举根节点或者GC的全过程是需要执行线程暂时停顿下来的，而考虑到效率问题，我们又希望这个停顿越短暂越好。所以，目前主流的Java虚拟机都采用的是准确式GC（相对应的为保守式GC），当执行系统停顿下来后，我们不需要一个不漏地检查完所有执行上下文和全局的引用位置。在HotSpot的实现中，是使用一组称为OOPMap的数据结构来达到这个目的的，首先在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描的时候，就可以根据OOPMap上记录的信息准确定位到哪个区域中有对象的引用，这样大大减少了通过逐个遍历来找出对象引用的时间消耗。

##### 记忆集与卡表

记忆集是一种记录从非收集区域指向收集区域的指针集合的抽象数据结构

卡表是记忆集的一种实现方式，卡表的形式最简单形式是一个字节数组称为Card_Table，Card_Table中的每一个元素都对应着内存中固定大小的内存块，这些内存块被称为卡页card_Page，HotSpot中一个卡页的大小是512字节。在一个卡页中存储不止一个对象，只要卡页中的一个对象的字段存在着跨代指针，那么这个卡页就是脏的，称为脏页。在垃圾收集发生时，只需要将脏页中的对象加入GC Roots中一起扫描。

##### 写屏障

卡表是如何维护的呢？

在HotSpot中是通过写屏障（Write Barrier）实现维护卡表状态的。写屏障可以看作是 引用类型字段赋值 这个动作的AOP切面。在赋值前的写屏障称为写前屏障，赋值后的称为写后屏障。应用写屏障之后，赋值操作会伴随着更新卡表的操作。除此之外由于伪共享的存在，导致写屏障的性能降低，所以HotSpot增加了一个参数-XX:+UseCondCardMark参数用来控制是否判断卡表中的元素是否被标记过，以提升性能。

##### 并发的可达性分析

当我们确定了GC Roos对应的对象之后，就可以沿着这些GC Roots对象向下遍历，而随着堆越来越大，引用关系越来越复杂，就会导致向下扫描的时间越来越长。

想要减少扫描期间带来的时间停顿，可以在向下搜索采用和用户线程并发扫描的方式降低时间停顿，所以引入了三色标记法，用来辅助推导，按照是否被访问过将对象分为三个颜色：

- 白色：表示尚未被收集器访问到的对象，在分析结束之后，白色的对象即表示不可达，可以被回收
- 黑色：表示对象已经被收集器访问过，并且这个对象的全部引用对象都已经被扫描，代表存活。黑色对象不可以直接指向白色对象
- 灰色：表示对象已经被收集器访问过，但是至少有一个对象的引用没有被扫描过。

由于在扫描阶段，用户线程还在运行，所以会导致之前的引用关系改变，也就是图的结构发生变化。导致一是将已经死亡的对象标记为存活，这种会导致浮动垃圾，需要在下一次GC回收，另外是导致存活的对象标记为死亡，这就回导致问题。

专家证明了满足下面两种条件的前提下会导致对象的消失：

1. 赋值器插入了一条或者多条从黑色对象到白色对象的引用
2. 赋值器删除了全部从灰色对象到白色对象的直接或者间接引用

所以在解决并发扫描期间的问题，只需要破坏上面两个条件中的一个条件即可，这两种方案分别是==增量更新==和==原始快照（SATB）==

增量更新：当黑色对象插入了指向白色对象的引用之后，将这个增量的引用记录下来。等并发扫描结束后，再将记录中的黑节点为根，重新扫描一次。

原始快照：当灰色对象要删除指向白色对象的引用时，就将这个删除的引用记录下来，当并发扫描结束之后，在以记录中的灰色对象为根，重新扫描一次。

以上引用对象的关系的记录操作是通过写屏障实现的，CMS采用的是==增量更新==，而G1则是采用==原始快照（SATB）==实现的

#### 经典垃圾收集器

查看本机的jvm垃圾收集器   java -XX:+PrintCommandLineFlags -version

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902170613740.png)

各种垃圾收集器的并发停顿情况，浅色代表STW，深色代表并发

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200903110554731.png)

##### Serial收集器

这个收集器是一个单线程工作的收集器

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902171151232.png)

当Serial收集器垃圾收集时，用户的线程必须全部暂停，收集结束后恢复。

当前Serial收集器也有它的应用场景，Serial收集器由于不需要线程切换且额外内存消耗小，对于客户端虚拟机来讲，是一个最优的选择，垃圾收集一般在十几毫秒，做多控制在一百号秒内，STW是完全可以接受的！

##### ParNew收集器

ParNew收集器是Serial收集器的多线程版本，除此之外没有什么变化。默认开启和处理器核心数量相同的线程数。
![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902171629074.png)

虽然ParNew收集器和Serial收集器相比没有多少创新，但是由于CMS除了Serial收集器只能和ParNew收集器配合工作，所以还是有很多虚拟机的首选收集器。

当指定老年代采用CMS收集器时，新生代默认采用ParNew收集器。

当然也可以手动指定：==-XX:+/-UseParNewGC==

##### Parallel Scavenge

Parallel Scavenge在大多数特性上都与ParNew收集器相同，与CMS等收集器不同的是，Parallel Scavenge关注的是吞吐量。也就是最大限度的提升用户代码执行的总时间。

Parallel Scavenge提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio -XX:+UseAdaptiveSizePolicy 等参数用来调整垃圾收集的时间

##### Serial Old收集器

Serial Old是Serial收集器的老年代版本，主要的意义也是用在客户端模式下的模式下。在服务端的模式下，主要用于JDK5以前与Parallel Scavenge搭配使用，另外一种就是作为CMS在发生异常时的备选方案。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902193355335.png)

##### Parallel Old

Parallel Old是Parallel Scavenge的老年代版本，支持多线程并发收集。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902193618552.png)

Parallel Old基于标记整理算法实现。这个收集器实在JDK6之后提供的。在注重吞吐量或者处理器资源比较稀缺的情况下可以考虑使用这组搭配。

##### CMS

CMS关注的是系统的响应速度，也就是STW时间短，其中初始标记和重新标记需要STW。CMS是基于并发清除算法的，整个过程分为四个步骤：

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200902195826427.png)

- 初始标记：标记一下GC Roots能够关联到的对象，速度很快。
- 并发标记：从GC Roots直接关联的对象开始遍历整个对象图的过程，时间较长，但是用户线程不需要停顿。
- 重新标记：为了修正并发标记期间，用户线程导致的标记产生变动的那一部分对象的标记记录，这个时间比初始标记时间略长
- 并发清除：清理掉标记阶段判定已经死亡的对象，和用户代码并发执行。

缺点：

- 当CPU核数较少时，占用CPU资源较高，占用了部分CPU的运算能力

- 无法处理浮动垃圾，在CMS执行并发标记和并发清理的期间，用户线程还是在继续运行，这个时候产生的垃圾CMS没办法在本次GC手机，只能在下一次GC收集。另外CMS要求必须预留一部分内存供并发收集时程序的运作使用。如果预留的空间不足，会发生Concurrent Mode Failure异常，此时不得不采用备选的方案：冻结用户的线程，采用Serial Old收集器执行一次GC，这样收集一次垃圾的时间会很长。预留空间的阈值通过-XX:CMSInitiatingOccupancyFraction来调整，JDK以后默认为92%会触发老年代GC。
- 最后由于CMS采用并发清理算法，会导致大量的内存碎片，当内存碎片化导致大对象无法分配内存，就会触发Full GC。CMS提供了-XX:+UseCMSCompactAtFullCollection参数，实现在每次执行Full GC前整理内存空间，时间较长。

##### Garbage First收集器

G1收集器作为java的里程碑式的收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。在JDK9之后，G1宣布取代了Parallel Old和Parallel Scavenge的组合，成为服务器模式下默认的垃圾收集器。在G1收集器之前出现的所有的垃圾收集器，垃圾收集器的目标范围都是要么新生代，要么老年代，要么就是Full GC。而G1可以面向java堆中的任何部分来组成回收集进行回收。衡量的标准变为哪些Region存放的垃圾最对，最有回收的价值，这就是G1的Mixed GC模式。

首先G1也是基于分代收集理论设计的，但是G1将堆分成了多个大小相等的独立区域（Region），每一个Region都可以按照需要扮演新生代的Eden空间、Survivor空间和老年代的空间。Region中还有一种特殊的Humongous区域，用来存储大对象，G1认为当对象超过Region内存的一半即可判定为大对象，超出一个Humongous大小采用N个Humongous区域存储，G1通常将Humongous区按照老年代一样看待。

G1可以实现在可预测的停顿时间模型内完成垃圾收集，是因为G1收集器去跟踪每个Region中垃圾价值的多少，价值即收集所获得的空间的大小和回收时间成本的经验值，根据价值维护一个优先级列表，每次根据用户设置的停顿时间，优先回收价值大的Region。

G1的技术难点：

1. 如何解决跨代引用对象的问题？

   G1的每个Region都会有自己的记忆集，记忆集会记录别的Region指向自己的指针，并标记这些指针位于哪些卡页的范围内。本质就是一个Hash表，key是别的Region指向自己的指针，value是一个集合存储卡表的索引号

2. 并发标记阶段如何保证收集线程与用户线程互不干扰的工作？

   在CMS中是通过增量更新算法实现的，而G1是通过原始快照算法实现的。在标记过程中新对象的分配，G1采用两个TAMS的指针，在Region中划分出一个区域，用于新对象的分配。

3. 怎样建立起可靠的停顿预测模型？

   以衰减均值理论为基础实现的

G1在整体上是基于标记整理的算法，局部的Region清理采用的是标记复制算法实现。

G1的运行过程大致步骤

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200903003304360.png)

- 初始标记：标记一下GC Roots能够直接关联到的对象，并且修改TAMS指针的位置。这个阶段停顿线程，但是时间很短。
- 并发标记：从GC Roots对象开始对堆中对象进行可达性分析，递归扫描整个堆里的对象，找出要回收的对象。这个过程耗时较长，和用户线程并发执行。当对象扫描完成以后，还需要重新处理在SATB记录下的在并发时候有引用变动的对象。
- 最终标记：对用户线程做一个短暂的暂停，处理并发阶段结束后遗留下来的少量的SATB记录。
- 筛选回收：负责更新Region的统计数据，根据Region的回收价值进行排序，根据用户指定的执行时间选择Region形成回收集，然后将回收集中存活的对象复制到空的Region中，在清理掉整个回收的Region。这个过程必须暂停用户的线程。

由于G1可以针对回收时间由用户指定，指定的期望停顿时间设置为100～300ms是一个合理的值。

从G1开始，最先进的垃圾收集器都将设计导向为不追求一次将java堆全部清理干净，只要收集的速率可以满足对象分配的速率，那一切就能运行的很完美。

和CMS收集器对比：

- 优势
  - 与CMS的标记清除算法不同，G1长时间运行不会导致内存碎片化。
  - 可以指定最大停顿的时间
  - 从算法的理论上来看更有潜力
- 劣势：
  - G1的卡表实现更为复杂，占用更多的内存。
  - 除了和CMS一样采用写后屏障实现卡表的维护操作外，为了实现原始快照搜素（STAB）算法还需要采用写前屏障来跟踪并发时的指针变化情况，导致用户代码执行中存在更大的负担。G1的写屏障操作，消耗了更多的运算资源。

按照实践经验来看，CMS更加适用于小内存的系统，G1更适合大内存的系统。这个平衡点通常在6～8G内存之间。

##### Epsilon

是一款不能收集垃圾的垃圾收集器，更倾向于把它称为自动内存管理子系统。如果程序运行时间很短，只要在堆上能够正常分配对象，并且在堆耗尽之前退出，就可以考虑使用Epsilon

#### 选择合适的垃圾收集器

##### 收集器的权衡

考虑使用哪款垃圾收集器主要取决于以下三个因素：

1. 运行应用的基础设施
2. 使用JDK的发行版本
3. 关注的是吞吐量还吃延迟还是内存

如果能掌握硬件的型号，使用较新的版本，关注的是延迟，就可以使用ZGC

如果是针对JDK比较老的版本，JDK8的话可以考虑使用CMS，默认使用Parallel收集器组合，JDK9可以考虑使用G1。

##### 虚拟机及垃圾收集器日志

具体的信息看3.7.3节吧

下面配置针对的是JDK8

查看GC基本信息： -XX:+PrintGC

查看GC详细信息：-XX:+PrintGCDetails

查看GC前后堆变化：-XX:+PrintHeapAtDC

查看GC用户线程并发时间及停顿时间：-XX:PrintGCApplicationCocurrentTime

查看GC后剩余对象的年龄分布信息：-XX:+PrintTenunringDistribution

##### 虚拟机垃圾收集器参数汇总

3.7.4节

#### 内存分配与回收策略实战

对象在内存上的分配，基本上都是在堆上进行分配（还有栈上分配），对象分配的规则取决于jvm使用哪种垃圾收集器，一起虚拟机上关于内存相关的参数。

### 虚拟机性能监控、故障处理工具

#### 基础故障处理工具

##### jps   虚拟机进程状况工具

jps（jvm process status tool）是虚拟机进程状况工具，可以列出正在进行的jvm进程的主类名以及这些进程的本地虚拟机的唯一ID（LVMID），是使用频率最高的工具，因为其他工具需要配合LVMID来实现监控哪一个jvm进程。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200904154144889.png)

使用：jps [options]               例如：jps -l     列出进程的LVMID和主类名

##### jstat    虚拟机统计信息监控工具

全称 **jvm statistics monitoring tool**，只要监控虚拟机各种运行状态的命令行工具，他可以显示本地或者远程的虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时信息。

命令：jstat option vmid        以 jstat -gc vmid 250 20 为例，表示每隔250ms查询一次，一共查询20次

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200904155551156.png)

##### jinfo java配置信息工具

全称 configuration info for jvm，作用时实时查看和调整jvm各项参数。这个命令在mac上会报错，需要jdk9以上。

jinfo -flags process_id      查看当前正在运行的java程序扩展参数

jinfo -flag MaxMetaspaceSize 17808    查看具体的扩展参数

jinfo process_id        

jinfo -sysprops process_id

除查询jvm参数和系统变量信息外还可以动态修改配置。 -flag[+/-]name或者-flag name=value

##### jmap  java内存映射工具

jmap用户生成堆转储快照，当然jmap不仅仅是为了获取堆转储快照，它还可以查询finalize队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。

命令：jmap [option] vmid

jmap -dump:format=b,file=dump.bin 39480

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200904171342458.png)

##### jhat   虚拟机堆转储快照分析工作

JDK提供jhat命令和jmap命令搭配使用，用来分析jmap生成的堆转储快照。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200905161829988.png)

##### jstack    java堆栈跟踪工具

用于生成虚拟机当前时刻的线程快照，通常是定位线程出现长时间停顿的原因，如线程间的死锁、死循环、请求外部资源导致线程的长时间挂起。当线程出现问题通过jstack查看各个线程的调用堆栈。

命令：jstack [option] vmid

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200905165847563.png)

除了jstack之外，java在java.lang.Thread里面提供了一个getAllStaskTraces()方法用于获取所有线程的StackTraceElement对象。

#### 可视化处理工具

##### JHSDB 基于服务性代理的调试工具

这个工具是在open JDK9中提供的，用的时候再具体看

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200907095427923.png)

##### JConsole java监控与管理控制台

JConsole是一款基于JMX的可视化监控、管理工具。

启动方式：在mac或者windows下启动JConsole控制台，连接本地或者远程的java进程。

JConsole可以看作是一些常用的jstat、jstack的页面，页面包括概述、线程、内存、类、vm摘要、MBean等信息

##### VisualVM  多合---故障处理工具

VisualVM监控范围：

- 显示进程的配置、详细信息(jinfo、jps)
- 监视处理器、垃圾收集、内存、堆、线程和方法区的信息（jstat、jstack）
- 线程和堆的dump（jmap、jhat）
- 方法级别的程序性能分析，找出调用最多、执行时间最长的方法
- 离线程序快照
- 其他插件

通过安装各种插件可以实现方法调用时间监控、线程和堆dump转储、性能监控、甚至方法追踪。

##### java mission control   可持续在线的监控工具

待看

### 调优案例与实战

### 类文件结构

Oracle和其他公司发布过很多款java虚拟机可以在各种硬件和系统的jvm，这些虚拟机可以执行同一种与平台无关的字节码，从而实现了“一处编写，到处运行”。

整体的过程为 .java程序通过javac编译为.class文件，也就是字节码文件，jvm执行字节码文件。jvm除了支持java语言之外，同样支持其他很多语言，就是将其他语言的代码文件通过编译器编译为.class文件，jvm同样可以执行。

#### class类文件的结构

class类文件的结构表示数据项的结构，这种伪结构只包含两种数据：无符号数（ u1、u2、u4、u8）和表（以_info结尾，用来表示有符合关系的复杂对象）

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200910105428163.png)

##### 魔数与class的版本

magic就是魔数，在java的class文件中u4为CA FE BA BE

后续的两个mior_version和major_version代表了当前class文件的版本信息，例如如果用JDK8进行编译的class文件对应的major_version为52，由于java class版本的向后兼容，那么只有在更高的JDK版本的jvm才能执行这个class文件

##### 常量池

常量池采用u2来表示常量池中常量的数量，cp_info表。在常量池中主要存储两种数据，字面量和符号引用（包括被模块导入或者开放的包，类和接口名，字段的名称和描述符，方法的名称和描述符，方法句柄和方法类型，动态调用点和动态常量）

其实简单理解起来就是大表套小表，用来表示类的基本信息

##### 访问标志

access_flag用来表示这个类是接口还是类，是private还是public、abstract、final、enum、annotation等信息

##### 类索引、父类索引、接口索引

类信息和父类信息都是采用u2的数据存储，存储的值为在常量池中的位置信息，例如类信息，存的是0X0001，就是对应常量池中第一个常量。

##### 字段表集合

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200910142730178.png)

##### 方法表集合

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200910142709896.png)

##### 属性表集合

#### 字节码指令简介

### 虚拟机类加载机制

java虚拟机把类描述文件加载到内存，并对数据进行校验、转换解析和初始化最终生成java虚拟机能直接使用的java类型，称为类加载机制。

#### 类加载的时机

下图为类加载的过程，其中除了解析外，执行的开始顺序必须按照下列的顺序执行，而解析在有些情况下可能在初始化之后执行。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200910172043172.png)

类的初始化情况：

1. 遇到new、getstatic、putstatic、invokestatic四条字节码的时候，如果类没有初始化过，会先执行类的初始化。简单来说就是new、静态方法、静态变量
2. 使用反射包对类进行反射调用的时候
3. 当初始化类时，父类没有被初始化的时候会优先初始化父类
4. 虚拟机启动时，执行main方法的类会被初始化
5. 动态语言支持，动态语言持有的句柄的类没有被初始化
6. 当一个类定义了default方法时，如果有接口的类初始化，接口也会初始化

接口的初始化情况和类基本一致，除了第三条，当接口初始化不会导致父接口初始化

#### 类加载的过程

##### 加载

非数组类的加载过程主要完成三个步骤：

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流中的静态存储结构转化为方法区的运行时数据结构
3. 在堆上生成一个代表这个类的java.lang.Class类型的对象，作为方法区这个类各种数据的访问入口

数组类和非数组类的加载有很大的不同，数组类本身不是通过类加载器创建，而是jvm直接在内存中动态构造出来，但是数组的类型还是通过类加载器加载。如果数组的类型是引用类型，那么加载完之后，数组将被标识在加载器的类名空间上。如果类型是基本类型，java虚拟机会讲数组与引导类加载器关联。

数组类的访问权限和组建类型的访问相同，如果是基本类型，则访问权限为public

##### 验证

完成以下四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证

##### 准备

准备阶段是正式为类中定义的静态变量分配内存并赋初始值的阶段，从概念上讲，这部分变量使用的内存应该都是在方法区上分配，但是在java8之后，类变量会随着class对象一起存放在java堆中。注意的是一般情况下这个阶段只是将类的静态变量赋0值，而具体用户指定的值会在初始化阶段进行，特殊情况如下b作为常量在准备阶段就已经被赋值为123；

例如

```java
static public int a = 123;        // 这个阶段赋0值
finanl static public int b = 123;          // 这个阶段赋123的值
```

##### 解析

解析阶段java虚拟机将常量池中的符号引用替换为直接引用的过程。

符号引用就是一组符号来描述所引用的目标，符号是可以无歧义的定位到目标的字面量即可。

直接引用是可以直接指向目标的指针，相对偏移量或者是能够直接定位到对象的句柄。

- 类或者接口解析：假设当前解析阶段的所处的代码的类为D，如果要把一个从未解析过的符号解析为一个类或者接口的直接引用过程主要包括递归的类加载以及访问权限的判断。
- 字段解析：要解析一个未被解析过的字段，首先针对符号引用的类信息进行解析，也就是字段所属的类或者接口。如果解析类或者接口成功，会在类中搜索字段，搜索到了解析结束，否则解析接口或者父类，向上搜索。搜索不到报错。
- 方法解析：和上面的类似
- 接口方法解析：和上面的类似

##### 初始化

类的初始化阶段是java虚拟机真正开始执行用户编写的代码。在准备阶段，变量已经赋过一次0值，而在初始化阶段，则会根据用户编写的代码主观计划的去初始化类变量和其他资源。初始化阶段就是执行类的\<clinit>()方法。

\<clinit>()是由编译器自动收集的变量的赋值和静态代码块static{}中的语句合并而成的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态代码块只能访问在static{}之前定义的变量，而在静态代码块之后定义的变量只能赋值不能访问。

子类的\<clinit>()执行之前，jvm会保证子类的父类的\<clinit>()方法先执行，所以最先执行的永远是java.lang.Object类的\<clinit>()方法。

\<clinit>()方法对于类和接口不是必须的，对于类来讲，如果没有静态代码块和静态变量，则编译器不会为类生成\<clinit>()方法。对于接口来讲如果接口存在静态变量，编译器会为接口生成\<clinit>()方法，但是接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法，而且，类的初始化方法也不会执行类的接口的\<clinit>()方法，只有当接口的静态变量被用到，才会执行接口的\<clinit>()方法。

需要注意的是，类的\<clinit>()方法执行在多线程下只能有一个线程执行，其他线程会阻塞等待执行线程执行完毕。所以如果\<clinit>()方法特别耗时会导致线程的阻塞。

#### 类加载器

java虚拟机有意的将加载阶段的“通过一个类的全限定名来获取一个类的二进制流”的动作放到虚拟机外部来做，实现这个动作的代码被称为==类加载器==

不同的类加载器加载的类是不同的，即使是来自于一个文件的类，被同一个jvm加载，如果是不同的类加载器加载，那么两个类就必定不相等。也就是说判断类是否相等的条件是两个类的加载器必须是一个。

##### 双亲委派模型

从jvm的角度来看，加载器分为两种：

- 一种是启动类加载器（BootstrapClassLoader）是由c++实现

- 另外一种是由java实现的，独立于虚拟机外部，继承自抽象类lava.lang.ClassLoader

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200911161017925.png)

启动类加载器加载 <JAVA_HOME>\lib目录下的类

扩展类加载器加载<JAVA_HOME>\lib\ext目录下的类，在实际开发中，可以使哟过扩展类加载器加载类。

应用程序类加载器负责加载用户类路径上所有的类库，开发者同样可以使用，在没有自定义加载器的情况下，默认采用应用程序类加载器。

上述图片表示各种加载器的关系，被称为双亲委派模型。双亲委派的工作过程为：当一个类加载器收到了加载类的请求，首先不会自己去尝试加载这个类，而是把这个类的加载任务委派给自己的父加载器，因此所有的类加载请求最终都会委派给启动类加载器，只有父加载器反馈自己无法完成这个加载请求，子加载器才会自己尝试去加载。

以下为双亲委派的代码：

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200911162459585.png)

##### 双亲委派模型的破坏

> 我们知道通过spi可以实现很多功能，例如MySQL，Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类，线程上下文类加载器可以通过Thread.setContextClassLoaser()方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器，很明显，线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则
>
> https://blog.csdn.net/justloveyou_/article/details/72231425

自定义类加载器：

> 既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。
>
> 定义自已的类加载器分为两步：
>
> 1、继承java.lang.ClassLoader
>
> 2、重写父类的findClass方法

自定义类加载器：

> https://www.cnblogs.com/szlbm/p/5504631.html

### 虚拟机字节码执行引擎

#### 运行时栈帧结构

栈帧是方法调用和方法执行背后的数据结构，也是运行时数据区的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址以及一些额外的信息。典型的栈帧结构如下所示：

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200912142031113.png)

##### 局部变量表

局部变量表是一组变量值的存储空间，用于存储方法的参数和在方法内定义的局部变量。

java的局部变量表采用32位的槽来存储数据，对于超过32位的数据，采用两个槽来存储，其中reference对象采用一个槽存储，long和double采用两个槽来存储，由于局部变量表是线程独立的，所以两个槽虽然不是原子操作但是不存在并发问题。

在局部变量表中的槽是可以重用的，如果当前字节码的PC计数器已经超出了某个变量的作用域，那么这个槽就可以交给其他变量来重用。

另外需要注意的一点是，局部变量和类变量不同的一点是，对于类变量在类加载的准备阶段会对类变量赋初始的0值，而对局部变量而言，必须对局部变量赋初始值才能使用。

##### 操作数栈

操作数栈也称为操作栈，当一个方法在开始执行的时候，操作数栈是空的，在执行代码的过程中会有各种字节码指令往栈中写入数据和提取数据，也就是入栈和出栈操作。

##### 动态连接

每个栈帧都包含一个指向运行时常量池中该方法所属的方法的引用，持有这个引用是为了支持方法在调用时候的动态连接。

##### 方法返回地址

当一个方法执行时，只有两种方式退出这个方法，遇到一个返回的字节码指令或者遇到了异常并且这个异常在程序中没有被妥善处理。

无论哪种退出的方式都必须回到最初方法被调用的位置，方法在返回时需要在栈帧中保存一些信息，用来恢复上层主调方法的执行状态。方法正常退出时，存储调用方法的PC计数器的值即可。而方法异常退出时，根据异常处理表来处理。

当当前方法退出过程相当于恢复上层方法的局部变量表和操作数栈，把返回值压入到调用者栈帧的操作数栈中，调整PC计数器的值指向调用字节码指令的下一条指令。

##### 附加信息

存储例如调试、性能信息相关的数据。

#### 方法调用

##### 解析

首先所有的方法调用的目标方法在Class文件中都是一个常量池的符号引用，在类加载的解析阶段，会讲其中一部分的符号引用转化为直接引用，这种解析能够成立的前提是：方法在调用之前就有一个确定的调用版本，这个方法的版本在运行期间是不可改变的。

java语言里符合解析条件的方法有：静态方法、私有方法、实例构造器、父类方法再加上被final修饰的方法。以上对用的字节码为invokestatic、invokespecial，注意的是，final方法虽然是invokevirtual，但是他无法被覆盖，所以是非虚方法，出了以上五种方法，都称为虚方法。

##### 分派

静态分派

- 对象的类型分为静态类型和实际类型，对于重载方法，使用哪个重载的方法，取决于传入参数的静态类型。静态类型在编译器就已经确定
- 所有依赖静态类型来决定方法执行版本的分派动作，称为静态分派。静态分派最典型的场景就是重载。
- 需要注意的是编译器虽然能够确定出方法的重载版本，但是在很多情况下这个版本并不是唯一的，往往只能确定一个相对适合的版本，优先找到最符合的重载方法，如果没有，就退而求其次。此外对于字面量来讲，没有显示的静态类型，例如 字面量 'a'， 如果重载方法有定义char类型的，则编译器优先将字面量重载方法确定为char类型，其次判断为int类型，如果连int也没有，就是long类型、其次Character类型、然后Serilizable、然后Object，最后char... ，这个例子可以看一下书

动态分配

- 和静态分派不同，动态分派主要与多态另一个重要体现重写有着密切的关联，对于重写的方法，称为虚方法，执行额字节码是invokevirtual，执行的过程是首先获取对象的实际类型，然后搜索对应的方法，如果搜索不到就继续搜索父类的方法，如果始终找不到合适的方法则抛出异常
- java重写的本质就是invokevirtual字节码的第一步会根据方法接收者的实际类型来选择方法的版本，这种根据运行期实际类型来确定方法的实际执行版本的过程称为动态分派
- 在java中，只有虚方法，没有虚字段，当通过类的方法访问某个名字的字段时，当子类中声明和父类相同的字段时，虽然子类的内存中两个字段都在，但是子类会屏蔽父类的字段。
- 这个代码重点看一下，理解输出的值

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200914170749084.png)

##### 单分派与多分派

方法的接受者与方法的参数统称为方法的宗量。根据宗量的数量分为单分派和多分派，对于如今的java来讲，java是静态多分派，动态单分派的语言。

##### 虚拟机动态分派的实现

对于动态分派，虚拟机在执行的时候基于性能的考虑一般不会频发的去搜索类型的元数据。面对这种情况，一种常见的手段是为类型在方法区建立一个虚方法表提升查询性能。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200914172158723.png)

如上图所示，Son重写了Father的全部方法，所以没有指向父类方法入口的箭头，但是没有重写Object的任何方法，所以有指向Object的箭头

#### 动态类型语言支持

动态语言最关键的特征是他的类型检查主体是运行期而不是编译期进行的。动态语言只有在运行时才能确定方法的接收者，在java中invokeinterface、invokevirtual、invokestatic、invokespecial字节码的第一个参数都是调用方法的符号引用。所以在java7中增加了一个invokedynamic字节码和java.lang.invoke包。

通过invoke包可以搜索到具体的方法句柄，以实现方法的调用。实际上java中早就提供了反射机制，可以实现，但是反射是在java层面实现的功能，invoke包是在字节码层面解。

invokedynamic字节码和其他四个字节码的区别是分派的逻辑不是由虚拟机决定的，而是由程序自己决定的。



#### 基于栈的字节码解释器执行引擎

在java中javac实现了程序代码经过词法分析、语法分析生成抽象语法树，再遍历抽象语法树生成字节码指令流的过程。这一部分是在虚拟机之外实现的，而解释器是在虚拟机之内的。

javac编译生成的字节码指令中，基本上是一种基于栈的指令集架构，字节码的大部分指令都是零地址指令，他们依赖于操作数栈进行工作。与之相对的另一种常用架构是基于寄存器的指令集。那么基于栈的指令集与基于寄存器的指令集有什么区别呢？

基于栈的指令集移植性更好，字节码更加紧凑，实现更简单；而基于寄存器由于存在硬件的区别移植性差，但是执行速度快，所以物理机都采用基于寄存器的架构。另外基于栈的架构只是在解释执行的情况下，如果是编译成汇编执行执行，那就与虚拟机采用哪种指令集无关了。

#### 类加载及执行子系统的案例与实战

##### Tomcat



##### 字节码生成计数及动态代理的实现

常见的字节码生成技术包括：javassist、ASM、CGLib之类的字节码类库。

除此之外就是动态代理技术，动态代理技术比较简单

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200917172111254.png)

对于上述代码，唯一的黑匣子就是Proxy.newProxyInstance()方法，可以跟踪这个方法最后的关键代码就是sun.misc.Proxy.generateProxyClass()方法，我们可以通过在main方法中增加下面这句代码

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200917172350770.png)

加入这句话之后就会在磁盘上生成一个名为“$Proxy0.class”的代理类Class文件

### 程序编译与代码优化



### 高效并发

#### 硬件的效率与一致性

由于处理器的运行速度很快，内存操作相对于处理器的处理速度相比有着几个数量级的差距，所以需要针对每个处理器都要有自己的高速缓存（速度与处理器匹配）来作为处理器和主内存的缓冲，这样在运算时将需要用到的数据复制到缓冲，执行完之后再将结果同步到主内存，处理器、高速缓存与主内存的关系如下。但是由于每个处理器的高速缓存都是独立的，所以它引入了一个问题：缓存一致性。为了解决缓存一致性问题，每个处理器在读写高速缓存就要遵循缓存一致性协议来实现数据一致性。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915113849899.png)

除了增加高速缓存之外，为了使处理器内部的运算单元能够进一步被压榨，处理器可能会对输入代码进行乱序执行优化，处理器会在乱序执行之后对计算结果进行重组，保证计算的结果与顺序执行的结果是一致的，但是并不能保证执行的先后顺序与输入代码的顺序是一致的。与处理器的乱序执行优化一样，java虚拟机中即时编译器中也有指令重排序的优化。

#### java内存模型

##### 主内存与工作内存

java内存模型主要定义了程序中各种变量的访问规则，即关注共享变量存储到内存和从内存中取出的底层细节。

内存模型规定了所有的变量都存储在主内存中，每个线程还有线程独立的工作内存，线程的工作内存中缓存了主内存中变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程也不能访问其他线程的工作内存数据。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915141741866.png)

##### 内存间交互操作

对于工作内存与主内存的交互，jvm定义了8中操作来完成。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915154325636.png)

java内存模型还规定了如下规则：

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915163116983.png)

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915163128210.png)

##### volatile

volatile关键字的主要变化在于对于volatille关键字修饰的变量在赋值后多了一条为“lock add1\$0x0, (%esp)”的字节码，add1$0x0前面的lock前缀指令的作用是将本处理器的缓存写入到主内存中，并且将其他处理器缓存无效化。

volatile的第一个语义是变量的可见性，当声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，因为处理器的缓存无效了。总结一下就是新值立马同步到主内存，以及使用前立即从主内存读取。

volatile的第二个语义是禁止指令的重排序，指令重排序的概念是volatile变量后面的代码不能重排序到volatile关键字修饰的变量之前，add1\$0x0操作是将volatile关键字之前的值写入到内存，意味着之前的操作都已经执行完成，这样就形成了“指令重排序无法越过内存屏障”的效果

##### 针对long和double型变量的特殊规则

虚拟机允许没有被volatile关键字修饰的long和double型变量的读写操作被拆分为两个32位的操作来执行，这就是所谓的“long和double的非原子性协定”

但是针对这个问题经过测试在主流的处理器中并不会出现这个问题，所以long和double型变量并不需要被定义为volatile

##### 原子性、有序性、可见性

原子性：对于基本类型的读写访问都是原子的，对于更大范围的原子操作，java内存模型还提供了lock和unlock操作实，体现在字节码上就是monintorenter和monitorexit来隐式的执行这两个操作，这两个字节码体现在synchronized关键字上，因此synchronized也具备原子性

有序性：有序性可以理解为在一个线程内观察，所有的操作都是有序的。在多个线程来观察都是无序的。volatile关键字本身包含了禁止指令重排序的语义；而synchronized关键字则是由一个变量在同一时刻只允许一个线程对其进行lock操作，相当于持有一个锁的线程串行执行。

可见性：volatile保证新值立马同步到主内存，以及使用前立即从主内存读取。除此之外，还有两个关键字synchronized关键字和final关键字可以实现可见性。synchronized的原理是unlock操作执行之前，必须将此变量同步回主内存。final关键字的原理是被final修饰的字段在构造器中一旦被初始化完成，其他线程就能看到这个对象。

#### java与线程

##### 线程的实现

我们知道线程是比进程更加轻量级的调度执行单位，线程的引入可以将资源的分配和执行调度分开，各个线程共享进程的资源，又可以独立调度。

java的线程是如何实现的呢？

线程实现的方式主要有三方式：使用内核线程实现、使用用户线程实现、使用用户线程和轻量级进程混合实现。

在java中主流的线程实现方式是采用内核线程实现的，内核线程是直接由操作系统内核支持的线程，这种线程由内核实现线程切换，内核通过调度器实现线程的调度，并负责将线程的任务映射到各个处理器上。那么程序呢不会直接使用内核线程，而是使用内核线程的一种高级接口-----轻量级进程，每个轻量级进程由内核线程支持，所以轻量级进程和内核线程是1:1的。

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200915201045229.png)

由于内核线程的支持，每个轻量级进程都称为一个独立的调度单元，即使某个轻量级进程阻塞了，也不会影响整个进程的运行。这种方式的缺点是：各种线程的操作如创建、析构以及同步都需要系统调用，而系统调用的代价相对较高，需要在用户态和内核态频繁切换。另外每个轻量级进程都需要一个内核线程的支持，而且轻量级进程需要耗费一定的内存资源，所以系统支持的轻量级进程的数量是有限的。

##### java线程调度

线程的调度是指系统为线程分配处理器使用权的过程，调度的方式主要有两种，协同式线程调度和抢占式线程调度。

协同式线程调度：线程的执行时间由线程自身控制，线程执行完自身的任务之后，要主动通知操作系统切换到另外的线程

抢占式线程调度：抢占式的线程调度是指每个线程将由系统分配执行时间，线程的切换不由线程控制。在java中Thread.yield()可以主动让出执行时间，但是线程如果想主动获取执行时间并没有办法。采用这种方式线程的执行时间是可控的，不会出现一个线程阻塞导致系统阻塞。

虽然java的线程是抢占式的，但是我们可以手动指定线程的优先级，来影响线程的执行

##### 线程状态转换

线程共有六种状态

#### java与协程

java的协程目前还没有发布

### 线程安全与锁优化

#### 线程安全

##### java语言中的线程安全

##### 线程安全的实现方式

1. 互斥同步：synchronized或者重入锁，两种方式的区别在于ReentrantLock提供了更过的功能，而synchronized写法更加简单，从性能角度考虑两种方式差不多
2. 非阻塞同步：CAS
3. 无同步方案：线程私有的ThreadLocal

#### 锁优化

##### 自旋锁和自适应自旋锁

自旋锁就是当线程执行到同步代码块时，如果获取锁失败不立即将线程挂起，如果线程持有这个锁的时间很短，线程挂起和恢复会带来很大的性能损耗，这时候采用自旋的方式等待持有锁的线程释放锁，从而避免线程的挂起和恢复线程的性能损耗。

自旋锁默认是开启的，并且我们可以手动指定自旋锁自旋的次数。

自适应自旋锁就是虚拟机根据上一次自旋的结果来自行判断本次自旋的次数，如果自旋刚刚获取锁成功了，那么这次可能会自旋更多次，如果自旋很少获得锁则有可能直接跳过自旋。

##### 锁消除

锁消除是指在即时编译器在运行时，对一些代码要求同步，但是对检测到不可能存在共享数据竞争的锁进行消除。

##### 锁粗化

首先原则上我们定义锁的代码块应该尽量小，但是如果针对一段零碎的代码都是针对一个对象进行加锁，将会把加锁同步的范围扩展到整个操作序列的外部。

##### 轻量级锁

轻量级锁是在JDK6中加入的，轻量级的名字是相对于操作系统互斥量来实现的传统重量级锁而言的。

传统的重量级锁是通过互斥量实现的，当线程获取锁时没如果获取成功进入到运行状态，获取失败则进入挂起状态。

轻量级锁的设计初衷是在没有多线程竞争的前提下，减少传统重量级锁采用互斥量产生的性能损耗

如下图展示的是对象头的Mark word

![image](https://github.com/wangjunjie0817/note/raw/master/images/image-20200917111137558.png)

对象头采用一种非固定的动态数据结构，针对对象不同的状态存储不同的数据

轻量级锁的工作原理：当代码进入到同步块的时候，如果同步对象没有被锁定，虚拟机首先在线程的栈空间建立一个名为锁记录（Lock Record）的空间，用于存储目前对象mark word中的拷贝，然后，虚拟机将使用CAS将mark word更新为指向Lock Record的指针。如果这个操作成功了，那么这个线程就拥有了这个对象的锁，并且将mark word中的标志位更新为00，表示进入轻量级锁状态。

如果这个操作失败了，就判断当前mark word中的指针是否指向的是当前这个线程，如果是，说明当前线程已经获取了锁，可以继续执行。否则，说明多个线程同时获取锁，此时轻量级锁膨胀为重量级锁，此时mark word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。

##### 偏向锁

偏向锁的目的是消除数据在无竞争下的同步原语，轻量级锁是在无竞争下采用CAS去消除使用同步互斥量，偏向锁是把整个同步都消除掉，连CAS也不做了。

他的意思是这个锁会偏向第一个获取锁的线程，如果在接下来的执行过程中，这个锁没有被其他线程获取，则持有偏向锁的线程的接下来操作永远不需要在进行同步。

一旦出现两外一个线程尝试获取锁的时候，偏向锁就马上结束，根据目前对象是否被锁定，决定是否撤销偏向，撤销后的状态恢复为未锁定或者轻量级锁状态。





















### 其他

##### 实参和行参、变量的内存分配      ==好多面试点，记录在这里==

行参是方法的参数，实参是调用方法时，传递的参数，例如下面的代码，name1就是实参，b方法的name2就是行参

```java
void a(){
	String name1 = "wang";
	b(name1);
}

void b(String name2){
	System.out.println(name2);
}
```

对象的内存分配分为以下几种情况：

- 对于基本类型：局部变量的内存分配在栈上，成员变量分配在堆上
- 对于引用类型：都分配在堆上，在栈上分配内存存储对象的引用
- 对于String类型，内存是分配在堆的字符串常量池中
- 对于包装类，真实的数据的内存还是分配在堆上

对于基本类型的数据内存分配，在声明时系统就给他分配4字节的内存，无论是否赋值。而引用变量，在声明时只分配了引用的空间，而不会在栈上为对象分配内存。

值传递：

- 对于基础类型，实参和行参传递的是实参的copy值，此时内存中存在两个相同的基本类型。
- 对于引用类型，实参和行参传递的是对象的引用地址

变量的作用域：

- 针对局部变量：函数的参数的作用域是整个方法，方法内变量的作用域是变量所在的{}内，超出作用域的变量对应的栈内存可以被重用
- 针对成员变量：作用域是全部 



##### 可变对象和不可变对象
